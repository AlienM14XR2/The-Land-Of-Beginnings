/**
 * 17 章　テキストファイルの読み書き
 *
 *
 * ファイルを開閉する関数
 * FILE型のポインタ変数 = fopen(ファイル名, モード);
 * fclose(FILE型のポインタ変数);
 * 
 * モード文字列 	目的
 * r 			読み込み。ファイルがない時は失敗。
 * r+ 			読み書き。ファイルがない時は失敗。
 * w 			書き込み。ファイルがあっても空のファイルを作る。
 * w+ 			読み書き。ファイルがあっても空のファイルを作る。
 * a 			追加書き込み。ファイルがない時は作る。
 * a+ 			追加読み書き。ファイルがない時は作る。
 * 
 * これを見ると、a+ でいいんじゃないのかな。
 *
 * 慣習的に、FILE型へのポインタ変数を、ファイルポインタと呼びます。
 * 
 *
 * バイナリファイルの読み書き
 * テキストとバイナリ
 *
 * バイナリファイルとはその名の通り、2進数で記録されたファイル、
 * 要するに、数値のみで記録されたファイルのことを意味します。
 * テキストファイルも、本質的にはバイナリファイルです。
 * しかし、テキストファイルは文字列で記録されているため、
 * テキストエディタなどで修正を行うことが容易です。
 * バイナリファイルも、特定のエディタで閲覧・修正できますが、
 * すべてのデータが数値の固まりになっているため、
 * 中身を見ても、その意味がまったくわかりません。
 * しかし、数値を直接書き込むため、サイズが少なく高速です。
 * 一般に、取り扱いを容易にする必要がある場合はテキストファイル、
 * 高速性が必要とされる場合にはバイナリファイルを利用することが多いようです
 *
 * バイナリファイルも、fopen関数、fclose関数を使って開閉します。
 * ファイル名、モードの指定方法もまったく同じです。
 * ただし、バイナリファイルを開く時には、モード文字列の最後にbをつけます。
 *
 * リトルエンディアンとビッグエンディアン
 * 数学では、100を16進数に変換すると、0064になります。
 * しかし、バイナリエディタで閲覧した結果では、6400になっています。
 * これは、インテル互換CPUの特徴で、リトルエンディアンと呼ばれる表現です。
 * この表現では、16進数を2桁ずつに区切り逆の順番で保存します。
 *
 * 一方、16進数の順番通りに表現する方式を採用するCPUもあります。
 * こちらはビッグエンディアンと呼ばれます。
 * リトルエンディアンはわかりにくく見えますが、
 * 先頭に意味がある数値が来やすいという利点があり、データ読み取り上有利なため、
 * 現代ではリトルエンディアンが主流となっています。
 *
 * バイナリファイルとテキストファイルの使い分け
 * バイナリファイルの利点は、読み書きが高速で、ファイルサイズが少なくなることです。
 * したがって、画像、動画、音、など、なるべく高速に扱いたいファイルは、基本的に
 * バイナリファイルです。それに対して、テキストファイルの利点は、人間が
 * 編集しやすいことです。困ったときには、テキストファイルにしておけば、
 * なにかと扱いやすくて重宝します。
 * 
 *
 * ドラッグへの対応
 * ドラッグされたファイル名の取得
 *
 * 前項までの解説で、最低限のファイル処理は行えるようになりました。
 * しかし、毎回ファイル名を入力するのは面倒です。
 * エクスプローラ等からドラッグして開けるようになれば大変便利です。
 * 実は、Windowsのコマンドプロンプト画面では、
 * ファイルをドラッグすれば、ファイル名が自動的に入力されます。
 * この方法であれば、ファイル名の入力は簡単にできます。
 * しかし、実行ファイルにファイルをドラッグした場合はできません。
 * C言語には、アプリケーションの起動時にファイル名を渡す機能があります。
 * それが、コマンドライン引数です。
 *
 * コマンドライン引数を受け取れるmain関数
 * ```
 * int main(int argc, char* argv[]);
 * ```
 *
 * コマンドライン引数の表示
 * ```
 * printf("%s",argv[0]);
 * ```
 * コマンドラインの0番目は、アプリケーション自身のファイル名になります。
 * エクスプローラ等からドラッグしたファイル名は1番目に格納されています。
 *
 * */

#include "stdio.h"
#include "stdlib.h"
#include "ctype.h"
#include "string.h"

// なんかひとまず、使いそうなの先にインクルードしちった。
// Java で使いもしないライブラリをインポートするとIDEと厳格なヒトにまぁ
// 叱られるだろう。
void println(const char* message) {
    printf("%s\n",message);
}
void debug_d(const char* message, const int debug) {
    printf("DEBUG: %s\t%d\n",message,debug);
}
void debug_f(const char* message, const double debug) {
    printf("DEBUG: %s\t%f\n",message,debug);
}
void debug_s(const char* message, const char* debug) {
    printf("DEBUG: %s\t%s\n",message,debug);
}
void debug_ptr_pd(const char* message, const int* pd) {
    printf("DEBUG: %s\t%p\n",message,pd);
}
//int main(void) {
int main(int argc, char* argv[]) {
    println("START テキストの読み書き ===============");
    if(1) {
        debug_d("やらせはせん、やらせんはせんぞ！！",8);
	debug_f("大人は勝手なことばかりいう",3.14159);
	debug_s("これはとんだ大誤算だったな。","だが、俺のテクに乱れはないぜ!!");
	int g = 78;
	int* pg = &g;
	debug_ptr_pd("そこか（キラン。",pg);
	debug_ptr_pd("見えているのか？",&g);
        // All GreeeeeN OK. デバッグはいつでもできるぞ：）
    }
    if(1) {
        // 初心者なので、しっかりと学ばせていただきます。（写経だね。
	FILE* fp;
	// これもメモリ取得とその解放についてのひとつの解答か。
	fp = fopen("test.txt","w");
	fprintf(fp,"Hello C.\nこんにちは C。\n");
	int i = 100;
	fprintf(fp,"i is %d\n",i);
	fprintf(fp,"i adress is %p\n",&i);
	fprintf(fp,"i is %f\n",(double)i);
	fclose(fp);
	// 空のファイルができてる。うん確認したよ、w モードだと新規上書きだ。
	// 以前のファイル内容は消えてしまう。テストなら問題ないが重要なファイルを
	// これで開いたらと考えると恐ろしいな。Linux なら、多少の救い、管理者と
	// 実行者の権限をしっかりと分けていれば、いいが。
	// 「ファイルがあっても空のファイルを作る。」この表現だと実際どうなるのか
	// 実は私には理解できなかった。可能性がありすぎるから。概ね予想通りだった
	// のだが、自信がなかったのだ。
    }
    if(1) {
        // ファイルからの読み込み
	FILE* fp;
	char buff[256] = {'\0'};
	for(int i=0; i < 256 ; i++) {
	    buff[i] = '\0';
	}
	println("----- B");
	fp = fopen("test.txt","r");
	println("----- C");
	// fscanf 関数では、スペースが含まれた場合は、そこで読み込みを終了する。
	// csv tsv のようなフォーマットのある場合は有効だが、フリーフォーマットの
	// 場合は苦労する。
	// 少なくとも、fscanf 関数は、空のファイルの読み込みは実行時エラー、
	// コアダンプとなる。うん、確かめた。
	fscanf(fp,"%s",&buff[0]);
	println("----- D");
	debug_s("buff is ",buff);
	fread(buff,1,255,fp);
	fclose(fp);
	println("----- A");
	debug_s("buff is ",buff);
    }
    // fgetc	ファイルから１文字の読み込み
    // fgets	ファイルから１行の文字列の読み込み
    if(1) {
        FILE* fp;
	char buff[256] = {'\0'};
	fp = fopen("test.txt","r");
	int i = 1;
	while(fgets(buff,256,fp) != NULL) {
	    printf("%d 行目",i);
	    debug_s("",buff);
	    i++;
	}
	fclose(fp);
	// ファイル操作関数も標準で複数用意されているので、つど調べて
	// 動作確認すること。今は、ここまででOK。
    }
    if(1) {
        // バイナリファイルの開閉
	// 次のプログラムは、test.dat という名前のファイルを書き込む
	// ために開く例です。
	FILE* fp;
	fp = fopen("test.dat","wb");
	fclose(fp);
    }
    if(1) {
        // ファイルへの書き込み、fprintf 関数とは違うね。
	// fwrite 関数です。
	// test.dat に78という数値を書き込みます。
	// Ubuntu ユーザの俺は ghex で確認した。（おもろい。
	int rx = 78;
	char n = '\n';
	int fd3s = 7;

	FILE* fp;
	fp = fopen("test.dat","wb");
	fwrite(&rx,sizeof(rx),1,fp);
	fwrite(&n,sizeof(n),1,fp);
	fwrite(&fd3s,sizeof(fd3s),1,fp);
	fclose(fp);
    }
    if(1){
        // fwrite関数による書き込みでは、配列を1度で書き込むこともできます。
	// やり方は、変数の代わりに配列を指定するだけです。
	int buf[] = {10,100,1000,10000};
	FILE* testdat;
	testdat = fopen("test.dat","ab+");
	fwrite(buf,sizeof(buf),1,testdat);
	fclose(testdat);
    }
    if(1) {
        // fread 関数による読み込み
	int buf;
	FILE* testdat;
	testdat = fopen("test.dat","rb");
	fread(&buf,sizeof(buf),1,testdat);
	// ソースを改変していなければ162 行目あたりで記述した、rx変数の値、78
	// が出力されるはず。
	debug_d("buf is ",buf);
	fclose(testdat);
    }
    if(1) {
	// コマンドラインの0番目は、アプリケーション自信のファイル名になる。
        // 次のプログラムは、ドラッグされたファイル名を表示する例です。
	if(argc > 1) {
	    debug_s("argv[1] is ",argv[1]);
	}
	fflush(stdin);
	getchar();
	// 上の2行は画面の表示を止めるための処理です。実行待ちになり、
	// 適当なキーで終わります。
	// fflush(stdin)は邪道
	// 上の命令は、出力バッファを強制出力する関数である fflush で、
	// 入力バッファである stdin をクリアしています。
	// これは正しい使い方ではありません。邪道です。
	// この使用方法は練習段階でのみ使い、実際のアプリ開発では
	// 使わないでください
    }
    if(1) {
        // ここでは、-a と -s というオプションの有無を解析する例です。
	// e.g.) ./file.out -a -s test.txt
	while(argc > 0) {
	    argc--;
	    if(argv[argc][0] == '-') {
	        if(argv[argc][1] == 'a') {
		    println("-a オプション");
		}
		if(argv[argc][1] == 's') {
		    println("-s オプション");
		}
	    }
	}
    }
    println("=============== END テキストの読み書き");
    return 0;
}
