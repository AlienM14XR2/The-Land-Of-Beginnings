/**
 * 15 章　ポインタ変数の仕組み
 * 
 * 進め方は変えない、愚直に素直に真っ直ぐ遠回りも Welcome。
 * この方針のもと、今の課題、リファレンスには取り組む。
 * 俺は初心者だ。
 * https://9cguide.appspot.com/15-01.html
 *
 * CPUが1回で扱うメモリの2進数での桁数が、ビット数なのです。
 * 32 bit マシンなら、34 bits。
 * 64 bit マシンなら、64 bits。
 *
 * 8ビットは1バイトとも呼ばれていて、コンピュータの基本的な単位となっています。
 * 32 = 4 bytes X 8 bits
 * 64 = 8 bytes X 8 bits
 *
 * 8 bits が数値で表現できる範囲は、0-255 の計 256個。
 * 127 = 64 + 63
 * signed のプラスの上限理由は上の計算で分かるはず、0ビット目は符号を管理している。
 * 7    6    5    4    3    2    1    0   bit　列のイメージ
 * 64   32   16   8    4    2    1    +-　表現可能な数値の範囲
 * 128  0    0    0    0    0    0    0   
 * これが、マイナスの数値範囲が 128 の理由のだったはず。
 * ビット演算で符号逆転が一発でできるのもこれだったと記憶している。
 *
 * 7 ビット目は数値で64その前のビット数全てで表現できる数値は、７ビット目の数値 -1
 * これがビット計算の基本のはず。
 *
 * 32ビット、🔟進数で約42億番までの8ビットの数値を扱うことができるのです。
 * 
 * 変数とメモリの関係
 * 
 * メモリ上の番号を表示する
 * int i;
 * printf("%p\n", &i);
 *
 * おもろい、この関数を作ってみるよ。debug_p でいいか：）
 *
 * &付き変数の正体
 * 実は、&は変数のアドレスを求める演算子なのです。
 * +や×などと同じように、なんらかの計算を行うための記号なのです。
 * 
 * すべては値渡しである
 * 関数を呼び出す時に変数を指定した場合には、
 * 変数に記憶されている値が、呼び出された関数の実引数にコピーされます。
 * （うん、やっぱり、debug_ptr_d 関数は明らかなフライングだったね。）
 * 引数で数値を渡す方式を、値渡しと呼ぶことがあります。
 * ここで重要なのは、変数を実引数に指定しても、渡されるのは中身の数値
 * である点です。
 *
 * 参照渡し
 * 値渡しに対して、参照渡しという機能が存在する言語もあります。
 * これは、アドレスを渡す処理を自動的に処理してくれる機能です。
 * C言語では、値渡ししか出来ないのですが、
 * アドレスを渡すことを慣習的に参照渡しと呼ぶことがあります。
 * （うん、だからさ、いっち番最初にさ、決めたんじゃないのC++は忘れるって。
 * なのに、勝手に暴走して先走るからさ。orz ：）
 *
 * 配列名は配列の最初の要素のアドレスを表しています。
 * したがって、配列名を渡せば、配列の場所がわかるため、&は不要です。
 * 配列名だけを渡している場合、確かに見た目には&をつけていないのですが、
 * 実際に行っていることは、&付きの変数を指定しているのとまったく同じなのです。
 *
 * アドレスを記憶する変数
 * ポインタという単語
 *
 * */

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "ctype.h"
#include "memory.h"

/**
 * メモリ上の番号を表示する関数です。
 * */
void debug_pd(const char* message, const int debug) {
    printf("DEBUG: %s\t%p\n",message, &debug);
}
/**
 * 自分の興味に素直に動く、これは私の興味だ、レファレンスから逸脱している。
 * レファレンスを読み進めれば答えてくれるかもしれない、しかし、それではダメ
 * なのだ、私は。
 *
 * 次の関数はコンパイルエラーにならないのか、まずはそれだ。
 */
//void debug_pdr(const char* message, const int& debug) { // 残念だったなフライングだ、この記述が許されるのはC++ だ。
void debug_ptr_d(const char* message, const int* debug) {
    // ここで注意すべきは debug はポインタ変数であること。
    // つまり、ポインタが指しているアドレスが知りたいのであれば
    // コメントアウトしていない、本来の記述で間違いはない。
    // printf("DEBUG %s\t%p\n",message, &debug);
    // としてしまうと、ポインタ変数のアドレスを出力してしまう。
    // もう、分かるよね。
    printf("DEBUG: %s\t%p\n",message, debug);
}

// これが、オレのやり方だ。
void println(const char* message) {
    printf("%s\n", message);
}
void debug_d(const char* message, const int debug) {
    printf("DEBUG: %s\t%d\n",message, debug);
}
void debug_f(const char* message, const double debug){
    printf("DEBUG: %s\t%f\n",message, debug);
}
void debug_c(const char* message, const char debug){
    printf("DEBUG: %s\t%c\n",message, debug);
}

// 流石先生、オレが配列でTODOにしたことを語っていた。
// 無論、オレはずるして先を読んだりしていない。
// このリファレンスが初心者が興味、不思議に思うことに的確なだけだ。
void sample_int_array() {
    println("-------------------- sample_int_array");
    int array[10];	// 初期化しない先生、宣言だけとは豪胆な：）
    printf("array is \t%p\n",array);	// これだけは自作関数では表現できない、理由は分かるよね、そう&を付けないのだよ、この場合は。
					// DONE 私の予想は合っていた。
					// array と &array[0] のアドレスは同じだ
					// そこでまた、次の疑問がわいてくる。
					// &array は？　これはオリジナル関数の問題
					// が解決した後、検証する。
					//
    for(int i=0; i < 10 ; i++ ) {
        printf("array[%d] is %p\n",i, &array[i]);
    }
    // 一つの疑問がある
    for(int i=0; i < 10 ;i++) {
        printf("array[%d] ",i);
	debug_pd("is ",array[i]);
    }
    println("見やすさって大事なんだな：）");
    // どうして、オリジナル関数 debug_pd がお前の期待したものじゃないか分かるかい。
    // 答えてみよう、ずぱり、変数のコピーだからだ。
    // 仮引数にはもとの変数のコピーが渡されているはずだ。
    for(int i=0; i < 10 ;i++) {
        printf("array[%d] ",i);
	debug_ptr_d("is ",&array[i]);
    }
    // どうだ、これなら、同じになっただろ：）
}

int main(void) {
    printf("START ポインタ ===============\n");
    println("始めるよ、ポインタ");
    debug_d("そこか！！",78);
    debug_f("ドムが。。。全て orz",3.14159);
    debug_c("叙事詩、そのはじまり。",'G');
    // 実行時ごとにその番号が変化する。
    // この小さな実行ファイル（アプリ）が起動ごとに空いているメモリを
    // 利用していることの証拠か。
    debug_pd("これでメモリ上の番号が分かるのか？ 整数リテラルの 369 is ",369);
    debug_pd("はい、これがアドレスです。",999);
    sample_int_array();	// 少しフライングしたがいい勉強になった。
    
    printf("=============== ポインタ END\n");
    return 0;
}

