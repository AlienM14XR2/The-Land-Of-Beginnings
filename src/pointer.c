/**
 * 15 章　ポインタ変数の仕組み
 * 
 * 進め方は変えない、愚直に素直に真っ直ぐ遠回りも Welcome。
 * この方針のもと、今の課題、リファレンスには取り組む。
 * 俺は初心者だ。
 * https://9cguide.appspot.com/15-01.html
 *
 * CPUが1回で扱うメモリの2進数での桁数が、ビット数なのです。
 * 32 bit マシンなら、34 bits。
 * 64 bit マシンなら、64 bits。
 *
 * 8ビットは1バイトとも呼ばれていて、コンピュータの基本的な単位となっています。
 * 32 = 4 bytes X 8 bits
 * 64 = 8 bytes X 8 bits
 *
 * 8 bits が数値で表現できる範囲は、0-255 の計 256個。
 * 127 = 64 + 63
 * signed のプラスの上限理由は上の計算で分かるはず、0ビット目は符号を管理している。
 * 7    6    5    4    3    2    1    0   bit　列のイメージ
 * 64   32   16   8    4    2    1    +-　表現可能な数値の範囲
 * 128  0    0    0    0    0    0    0   
 * これが、マイナスの数値範囲が 128 の理由のだったはず。
 * ビット演算で符号逆転が一発でできるのもこれだったと記憶している。
 *
 * 7 ビット目は数値で64その前のビット数全てで表現できる数値は、７ビット目の数値 -1
 * これがビット計算の基本のはず。
 *
 * 32ビット、10進数で約42億番までの8ビットの数値を扱うことができるのです。
 * 
 * 変数とメモリの関係
 * 
 * メモリ上の番号を表示する
 * int i;
 * printf("%p\n", &i);
 *
 * おもろい、この関数を作ってみるよ。debug_p でいいか：）
 *
 * &付き変数の正体
 * 実は、&は変数のアドレスを求める演算子なのです。
 * +や×などと同じように、なんらかの計算を行うための記号なのです。
 * 
 * すべては値渡しである
 * 関数を呼び出す時に変数を指定した場合には、
 * 変数に記憶されている値が、呼び出された関数の実引数にコピーされます。
 * （うん、やっぱり、debug_ptr_d 関数は明らかなフライングだったね。）
 * 引数で数値を渡す方式を、値渡しと呼ぶことがあります。
 * ここで重要なのは、変数を実引数に指定しても、渡されるのは中身の数値
 * である点です。
 *
 * 参照渡し
 * 値渡しに対して、参照渡しという機能が存在する言語もあります。
 * これは、アドレスを渡す処理を自動的に処理してくれる機能です。
 * C言語では、値渡ししか出来ないのですが、
 * アドレスを渡すことを慣習的に参照渡しと呼ぶことがあります。
 * （うん、だからさ、いっち番最初にさ、決めたんじゃないのC++は忘れるって。
 * なのに、勝手に暴走して先走るからさ。orz ：）
 *
 * 配列名は配列の最初の要素のアドレスを表しています。
 * したがって、配列名を渡せば、配列の場所がわかるため、&は不要です。
 * 配列名だけを渡している場合、確かに見た目には&をつけていないのですが、
 * 実際に行っていることは、&付きの変数を指定しているのとまったく同じなのです。
 *
 * アドレスを記憶する変数
 * ポインタという単語
 *
 * 世間では、アドレスの値を記憶する変数をポインタと呼んでいますが、
 * これは本当はあまり正確な呼び方ではありません。
 * なぜなら、ポインタとは、アドレスを扱う機能3つの総称だからです。
 *
 * 1つ目は、ポインタ型です。
 * 今まで出てきたint型やdouble型と同じような型です。
 * ただし、ポインタ型の場合、それらとは少し異なる特徴があります。
 *
 * 2つ目は、ポインタ値です。
 * これは、ポインタ型で扱える数値、要するにアドレスのことです。
 * 整数や実数といった数値の区別と同様に、ポインタ値という区別があるのです。
 *
 * 3つ目は、ポインタ変数です。
 * これは、ポインタ型で宣言された、ポインタ値を記憶できる変数のことです。
 * int型の変数やdouble型の変数と基本的には同じことです。
 * 
 * ポインタ型は、他の型と合体しなければこの世には存在出来ないという、
 * いわば、寄生虫のような型なのです。
 *
 * アドレスは、この章の始めで表示させたように、結局は整数値に過ぎません。
 * その整数値を記憶する型が、どうして他の型と合体する必要があるのでしょうか。
 *
 * 指定アドレスに記憶された数値を取り出すためです。
 * （コピーではダメな場合があったと解釈した、それに経験もした。）
 *
 * voidポインタ
 * 実際には、単独で存在するポインタ型としてvoid型があります。
 * この型は、どんな変数のアドレスでも記憶できますが、
 * 元々の変数の型がわからないため、値を取り出すことができません。
 * （元の型が分かっていたら取り出せるとも解釈できるのかな）
 *
 * ポインタ値 
 * 変数のアドレスの値のことです。
 * ポインタ値と通常の整数値とでは、その意味が明らかに異なります。
 * 通常の整数値は、プログラムの中で計算などを行うための数値ですが、
 * ポインタ値は、計算に使われる数値ではないからです。
 * つまり、この2つはどちらも単なる整数値ですが、その目的はまったく別なのです。
 * （やばい、まったく分からないのだが。アドレスのことだね。）
 *
 * ポインタ変数
 * この変数には、その元となった型の変数のアドレスを自由に代入できます。
 * さらに、記憶しているアドレスのメモリを読んだり書き換えたりできます。
 * （あぁ、ポインタ値とポインタ変数をオレが同一視してたのか。いや、
 * でも一回読んだだけではあっそうかとならないのがオレなのだね。）
 *
 * ポインタ変数では、記憶しているアドレス値を計算に使うことはありません。
 * ポインタ変数の役目は、それが指し示しているアドレス番号のメモリの値を
 * 計算することです。
 * （ここまでくると、先生が言ってることが分かってくる、ポインタ値と言ってる
 * のは、ﾆｱﾘｰｲｺｰﾙ　アドレス値ってことかな。）
 *
 * ポインタ変数そのものを計算に使うのではなく、それが指し示している変数を
 * 計算するのが、ポインタ変数の目的です。
 *
 * 変身機能こそが、ポインタ変数の最大の特徴となります。
 * （なんかええやん、調子でてきたやん、ええぞ）
 *
 * ポインタ変数モードでは、たいした機能は備えていません。
 * 具体的には、アドレスへの代入と足し算引き算だけしかありません。
 * なぜなら、ポインタ変数モードに必要なのはアドレスの記憶だけだからです。
 * （ここで少し、過去を思い出した、ポインタのインクリメント。その時は、構造体
 * のポインタだったと思うけど、それをインクリメントして、表示切り替えてたわ。
 * あるいは、連続したメモリ領域に、特定の型、サイズのデータを確保し、それを
 * インクリメント、デクリメントしてた。：）
 *
 * 通常変数モードに切り替わった場合、その性質は通常変数とまったく同じになります。
 * おかげで、通常の変数と同様にさまざまな演算子を使って計算できます。
 * 当然、その時に使われるメモリは、ポインタ変数モードで記憶したアドレスになります。
 * 
 * int* pa = &a;
 *
 * int* これが、ポインタ型と今は解釈している。
 * pa これが、ポインタ変数と今は解釈している。そして、pa の値がポインタ値、
 * この場合だと、変数 a のアドレスだと解釈している。
 * *P これが通常変数モードと解釈している。
 * これに何らかの演算を行うことは、変数 a の値を操作することに等しいと
 * 解釈している。
 *
 * こんな感じかな。3つの機能の総称というのは確かになと思った、余談ね。
 * int *p なのか int* p なのかは書き方の好みなのだと思っている。
 * GCC（g++）の C++ で試した際はどちらにも差異はなかったと記憶している。
 * 私は後者なのだ。C では違いはあるのかな、ないと思ってる。
 * よく分からずに使っていた時は前者だったような気もしている。
 * 面白いよね：）
 *
 * おっとまた、ちょっとミラクル、上の余談が次のリファレンスのはじまりだったか。
 * ただし少し残念だ、先生は前者を推してる。んー、推してるわけでもないのか、統一
 * するのでリファレンスは int *p だと。
 * （個人的にはint* pを使い続ける、キッパリ。：）
 * 
 *【仮想メモリ】
 * OSがメモリを管理して、多数のアプリに適切にメモリを振り分ける仕組みのこと。
 * 多数のアプリが同時に動く環境で、個々のアプリが勝手気ままにメモリを使うと、
 * 別々のアプリが使うメモリがかぶってしまい、正常に動作しなくなるので、
 * OSが管理して、個々のアプリが使うメモリがかぶらないようにしている。
 * （BIOS、これがリアルモード、実メモリ、危険地帯。ここで動くプログラムは相当な
 * 覚悟がいる。今のオレには到底無理。）
 *
 * C言語には、ヌルポインタが用意されています。
 * NULL という記号をポインタ変数に代入しておけば、
 * アドレスが代入されていない、つまり、まだ使える状態になっていないことを示せます。
 * int *p = NULL;
 * このようにすれば、if文で p == NULL であるか比較すれば、
 * p にアドレスが代入されているか区別できます。
 *
 * int *p = 0;
 * としてもヌルポインタが代入されます。
 * これはC言語の文法として決まっていることであり、
 * NULL が 0 であるということではありません。あくまでも NULL は NULL です。
 * NULL は 正しいアドレスが代入されていないことを示すための識別用の値であり、
 * 計算に使うための数値である 0 とは明確に区別されるものです。
 * もっとも、ほとんどのコンパイラでは NULL は 0 になってると思いますが・・・
 * （先生に親近感がわくのはこのたまにある、でもね、みたいな注釈なのかも：）
 *
 * ポインタの本当の使い方は、ショートカットとして使用することです。
 * Windowsのデスクトップに並んでいる、あのショートカットと同じです。
 *
 * 他の言語の参照と、C言語のポインタの最大の違いは、自動なのか手動なのか、です。
 * 他の言語の参照は、ほとんど自動でショートカットとして機能するようになって
 * いますが、C言語のポインタは、完全に手動であり、プログラマーが完全に理解して
 * 使わなければなりません。
 *
 * そのかわり、上級者がC言語のポインタを使いこなすと、ポインタだけで、
 * ほぼあらゆる制御構造、あらゆるデータ構造、を実現可能な強力すぎる機能となります。 * 実際、C言語のほとんどの機能が、ポインタで成り立っています。
 * （マジか、ワクワクしかないじゃん、先生の力強い激励に感謝。：）
 *
 * 配列型引数の奇妙な性質
 * 次の3つは同じ意味の仮引数宣言です。
 * ただし、この3つが同じ意味になるのは関数の仮引数宣言の場合のみです。
 * int getaverage(int data[10]);
 * int getaverage(int data[]);
 * int getaverage(int* data);
 *
 * そして、関数の中では、dataはいずれもポインタ型の変数です。
 * そして、呼び出し先と呼び出し元ではまったく同じメモリ領域の配列を使うことに
 * なります。
 *
 * どれにするか
 * この3つが同じ意味だと、どれを使って良いのか迷う人もいるかもしれませんが、
 * 筆者としては、2番目のように要素数を省略した形を使うことを勧めます。
 * なぜなら、3番目の宣言は、普通のポインタ型と紛らわしいからです。
 * 2番目の宣言であれば、配列を受け取ることが明示的にわかります。
 * 1番目の宣言は、C言語に慣れた人たちには幼稚な宣言に見えます。
 * （確かに、int main(int argc, char[] argv){}) みたいなのあるしね。）
 *
 * 配列とポインタの奇妙な関係
 * 配列のような使い方
 * (これは、サンプリングしよ。)
 * 
 * 配列とポインタはまったく別物
 * 多くの人が、配列とポインタを勘違いしてしまうようです。
 * 配列とは、多数の変数を順番つけでまとめて扱う方法であり、
 * ポインタとは、変数のショートカットを作る方法です。
 *
 * それなのに、似たような使い方ができるのは配列の設計と関係あります。
 * C言語では、配列を実現する手段として、ポインタを利用しているからです。
 * したがって、ポインタ変数では、配列と同等のことができてしまいます。
 *
 * そのため、ポインタと配列は混同しやすいのですが、
 * 配列はあくまでも多数の変数の先頭を示す固定された変数であり、
 * ポインタ変数は、好きな変数のアドレスを代入して、
 * 好きなメモリ領域を使うことができる可変的な変数です。
 * （最後にこの言葉が聞きたかった。ポインタを利用して設計されているのか、
 * 　そのために表層にそれが見えるという解釈。）
 * 
 *
 * ポインタ変数に配列のアドレスを代入すると、同じように使えると説明しました。
 * 同じように使えるとは、[]演算子で要素番号の指定ができるという意味です。
 *
 * しかし、実を言えば、ポインタ変数には、ポインタ変数用の書き方があります。
 * これは、ポインタ演算と呼ばれる書き方で、次のように書きます。
 *
 * ポインタ演算
 *  *(ポインタ変数 + 要素番号)
 * これもサンプリングしてみようね。オレが少し過去を思い出したのがこれだね。
 *
 * ポインタ演算、２つの書き方があるらしい。
 * サンプリングよろしく。
 *
 *
 * アドレスのことは忘れましょう
 *
 * 実際にプログラムを作るときには、
 * ポインタ変数がアドレスを記憶する変数であることはさっぱりと忘れてください。
 * 
 * なぜなら、ポインタ変数の本当の使い方とは、変数のショートカットとして
 * 使うことです。決して、アドレスを操作することではありません。
 * （ポインタのインクリメントが嫌いな先生：）
 * 使い方さえわかっていれば、内部処理がどんな仕組みだろうと無関係だからです。
 * （言い切ったね、気持ちいいよ。）
 * バグ修正の時にはポインタ変数がアドレスを記憶する変数であることを思い出し、
 * どこかで間違ったアドレスが代入されていないか調べなくてはならないでしょう。
 * （まぁ、言い放って終わりにはできないか：）
 *
 * よし、読み（書き）終えたようだな。次は演習だろ。
 *
 * また、思い出した。C の関数は基本値渡し、By Val、それかポインタしかない。
 * それはここまでの学習でしっかりと頭に入った。
 *
 * C++ で意識したことは次のことだ、関数、メンバ関数の仮引数の値はいじらない、
 * 変更しない、ということ。なぜか、それはそんな原則があることを知っていたから、
 * 呼び方は忘れた。なぜそんなものに準拠したかと言えば、どこで、何が変更されたのか
 * 、されるのかをはっきりさせるためだ。関数は演算は行う、しかしその演算に利用する
 * 引数の値は変えない、これを守るだけでコードの保守性、見通しが良くなると思った
 * から。なので、可能な限り C++ の関数、メンバ関数の定義で const を利用した。
 *
 * 翻って C 、MOTHER は出来ない。いや、戻り値があるのだから可能なように感じる
 * かもしれないが、それはそれで次の問題が生じる、例外(error)、無効(invalid)の
 * 扱いをどうするのか。C はやはり難Cii、自由に、書いた結果、本人でさえメンテ
 * 不可能なものが出来上がる可能性すらある。コーディング規約を予め決めて置く
 * ことでなんとかしているのか、世間は。想像し実行、そして改善していくことで
 * しか答えはでないかもな。
 *
 * もう一点非常に重要なこと、動的に確保されたメモリは誰が解放するのか、無論 MOTHER
 * は無関係だ、彼女はそんなことは知らない、知らなくていい。オレの原理原則に従えば
 * 「確保したものが解放する。」になる、しかし、本当にそれが守れるのか。
 * コンストラクタ、デストラクタのような仕組みがほしくなる、欲しければ自分で作る
 * しかない。（探せばあるかもしれない、しかしそれでは意味がない。サービスを期日に
 * 間に合うように作業している訳ではないから。）
 * やはり、クラスは必要なのだ。
 *
 * */

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "ctype.h"
#include "memory.h"

/**
 * メモリ上の番号を表示する関数です。
 * */
void debug_pd(const char* message, const int debug) {
    printf("DEBUG: %s\t%p\n",message, &debug);
}
/**
 * 自分の興味に素直に動く、これは私の興味だ、レファレンスから逸脱している。
 * レファレンスを読み進めれば答えてくれるかもしれない、しかし、それではダメ
 * なのだ、私は。
 *
 * 次の関数はコンパイルエラーにならないのか、まずはそれだ。
 */
//void debug_pdr(const char* message, const int& debug) { // 残念だったなフライングだ、この記述が許されるのはC++ だ。
void debug_ptr_d(const char* message, const int* debug) {
    // ここで注意すべきは debug はポインタ変数であること。
    // つまり、ポインタが指しているアドレスが知りたいのであれば
    // コメントアウトしていない、本来の記述で間違いはない。
    // printf("DEBUG %s\t%p\n",message, &debug);
    // としてしまうと、ポインタ変数のアドレスを出力してしまう。
    // もう、分かるよね。
    printf("DEBUG: %s\t%p\n",message, debug);
}

// これが、オレのやり方だ。
void println(const char* message) {
    printf("%s\n", message);
}
void debug_d(const char* message, const int debug) {
    printf("DEBUG: %s\t%d\n",message, debug);
}
void debug_f(const char* message, const double debug){
    printf("DEBUG: %s\t%f\n",message, debug);
}
void debug_c(const char* message, const char debug){
    printf("DEBUG: %s\t%c\n",message, debug);
}

// 流石先生、オレが配列でTODOにしたことを語っていた。
// 無論、オレはずるして先を読んだりしていない。
// このリファレンスが初心者が興味、不思議に思うことに的確なだけだ。
void sample_int_array() {
    println("-------------------- sample_int_array");
    int array[10];	// 初期化しない先生、宣言だけとは豪胆な：）
    printf("array is \t%p\n",array);	// これだけは自作関数では表現できない、理由は分かるよね、そう&を付けないのだよ、この場合は。
					// DONE 私の予想は合っていた。
					// array と &array[0] のアドレスは同じだ
					// そこでまた、次の疑問がわいてくる。
					// &array は？　これはオリジナル関数の問題
					// が解決した後、検証する。
					//
    for(int i=0; i < 10 ; i++ ) {
        printf("array[%d] is %p\n",i, &array[i]);
    }
    // 一つの疑問がある
    for(int i=0; i < 10 ;i++) {
        printf("array[%d] ",i);
	debug_pd("is ",array[i]);
    }
    println("見やすさって大事なんだな：）");
    // どうして、オリジナル関数 debug_pd がお前の期待したものじゃないか分かるかい。
    // 答えてみよう、ずぱり、変数のコピーだからだ。
    // 仮引数にはもとの変数のコピーが渡されているはずだ。
    for(int i=0; i < 10 ;i++) {
        printf("array[%d] ",i);
	debug_ptr_d("is ",&array[i]);
    }
    // どうだ、これなら、同じになっただろ：）
}
// 気づけば時刻は22時、そしてまったくコーディングしていなと知る。
// ちょっとサンプリングだ。
/**
 * この関数は仮引数であるポインタが指すアドレスの値に 100 を代入します。
 * （うん、非常に言葉を選んだよ。） 
 **/
void sample_plus_100(int* p_num) {
    debug_ptr_d("p_num's address is ",p_num);
    *p_num = 100;
    return;
}
/**
 * 数式の中に配列名を記述した場合、[]の記号の有無にかかわらず、
 * 配列名は、配列の先頭要素へのアドレス(ポインタ値)として扱われます。
 * そして、その配列名に[]をつけた場合、そのアドレスに番号の値だけ足し算を行い、
 * その結果として、足し算された分の番号の要素として扱われているのです。
 * */
int sample_get_average(int* data) {	// int data[] と書いても同じ動作をする。
    int i, average = 0;
    for(i = 0; i < 10 ; i++) {
        average += data[i];	// ポインタ変数なのに？
    }
    return average / 10;
}

/**
 * この章の演習問題、楽しみだ。
 *
 * 0～100の範囲で入力された複数の数値の中から、
 * 最大値と最小値を求めて表示するプログラムを作成せよ。
 *
 * -1が入力された場合は入力の終わりと判定する。
 *  ただし、最大値と最小値はmain関数以外の一つの関数の中で求める。
 *  また、入力された数値を記憶する配列の要素数は10とし、
 *  それ以上入力された場合はエラーが起きても仕方ないこととする。
 *
 * ヒント:配列の中に -1 があればデータの終わりだと判断できる。
 * ヒント:最小値を探すには、最大値を記憶した変数との比較を繰り返せば良い。
 * */
int handson_15_3_1(int nums[], const int size) {
    println("------------- handson_15_3_1");
    int tmp = -1, min = -1, max = -1;
    for(int i=0; i < size -1 ; i++) {
        if(nums[i] > nums[i+1]) {
	    tmp = nums[i+1];
	    nums[i+1] = nums[i];
	    nums[i] = tmp;
	}
    }
    max = nums[size-1];
    for(int i = 0; i < size ;i++) {
	printf("nums[%d] ",i);
        debug_d("is ", nums[i]);
    }

   for(int i=0; i < size -1 ; i++) {
        if( (nums[i] < nums[i+1]) || nums[i+1] == -1  ) {
            tmp = nums[i+1];
            nums[i+1] = nums[i];
            nums[i] = tmp;
        }
    }
   println("うん、見やすさは重要です。");
   min = nums[size-1];
    for(int i = 0; i < size ;i++) {
        printf("nums[%d] ",i);
        debug_d("is ", nums[i]);
    }
    debug_d("min is ", min);
    debug_d("max is ", max);
    return 0;
}
/**
 *
 */
int init_nums(int nums[], const int size) {
    println("--- init_nums");
    // int loop = sizeof(nums) / sizeof(nums[0]);
    //debug_d("loop is ",loop);
    for(int i=0; i < size ;i++) {
        nums[i] = -1;
    }
    
    return 0;
}

void test_handson_15_3_1(void) {
    println("--------------------------------- test_handson_15_3_1");
    int nums[11];
    init_nums(nums,11);
    nums[0] = 100;
    nums[1] = 1;
    nums[2] = 5;
    nums[3] = 30;
    nums[4] = 22;
    nums[5] = 1;
    nums[6] = 66;
    nums[7] = 47;
    nums[8] = 11;
    nums[9] = 0;
    nums[10] = -1;
    handson_15_3_1(nums,11);
}

int main(void) {
    printf("START ポインタ ===============\n");
    println("始めるよ、ポインタ");
    debug_d("そこか！！",78);
    debug_f("ドムが。。。全て orz",3.14159);
    debug_c("叙事詩、そのはじまり。",'G');
    // 実行時ごとにその番号が変化する。
    // この小さな実行ファイル（アプリ）が起動ごとに空いているメモリを
    // 利用していることの証拠か。
    debug_pd("これでメモリ上の番号が分かるのか？ 整数リテラルの 369 is ",369);
    debug_pd("はい、これがアドレスです。",999);
    sample_int_array();	// 少しフライングしたがいい勉強になった。
    if(1) {	// オレが学んだ楽して変数名のバッティングを防ぐ方法。
		// ヒントは実は JavaScript だったりする。
	int num = 10;
	debug_pd("num's address is ",num);
        sample_plus_100(&num);	// なるほどね、分かりやすい。C++ や Java のように
				// 参照の概念はなくても、ポインタとアドレスで表現
				// 出来てしまうのだね。今の私は、int& も型であると
				// 考えている。int とは根本的に違う、無論間違って
				// いるのかもしれないが、型として考えた方が
				// しっくり来るのだ、と C++ の事を語っている自分に
				// 気づく。そろそろ、恋しくなるよね：）
	debug_d("num's value is ",num);
	// value という変数名にしない理由はいくらでもある。
	// まぁそれはいいか。
    }
    if(1) {
	int average, nums[10] = {15,78,98,15,98,85,17,35,42,15};
        average = sample_get_average(nums);
	debug_d("average is ",average);
    }
    if(1) {
        int* data;
	int i, average = 0, nums[10] = {15,78,98,15,98,85,17,35,42,15};
	data = nums;	// ポインタ変数に配列のアドレスを代入
	for(i=0; i < 10 ; i++) {
	    average += data[i];	// 配列みたいに使える
	}
	debug_d("average is ",average / 10);
    }
    if(1) {
        int* data;
        int i, average = 0, nums[10] = {15,78,98,15,98,85,17,35,42,15};
        data = nums;    // ポインタ変数に配列のアドレスを代入
        for(i=0; i < 10 ; i++) {
            average += *(data + i); // ポインタ演算
        }
        debug_d("average is ",average / 10);
    }
    /**
     * 一般的にポインタ演算と言えば、こちらを指すことが多いようです。 
     * */
    if(1) {
        int* data;
        int average = 0, nums[10] = {15,78,98,15,98,85,17,35,42,15};
        data = nums;    // ポインタ変数に配列のアドレスを代入
        for(data=nums; data != &nums[10] ; data++) {	// オレが習ったのもこれだ。
            average += *data; // はい、ここに注目。
        }
        debug_d("average is ",average / 10);
    }
    test_handson_15_3_1();
    printf("=============== ポインタ END\n");
    return 0;
}

